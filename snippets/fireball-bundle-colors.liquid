{% comment %}Fireball - Bundle Color Pickers (Dawn 15.4) - requires product tag "7-Color-Bundles"{% endcomment %}
{% assign fireball_colors = "Red|Blue|Black|White|Green|Yellow|Orange" | split: "|" %}

<div id="FireballBundleColors-{{ section_id }}" class="fireball-bundle-colors hidden" data-max="4">
  <!-- Fireball - Provide product JSON so JS can always read variants reliably -->
  <script type="application/json" id="FireballProductData-{{ section_id }}">{{ product | json }}</script>

  <fieldset class="product-form__input">
    <legend class="form__label">Choose a color for each jar in your bundle.</legend>

    {% for i in (1..4) %}
      <div class="fireball-bundle-row" data-index="{{ i }}">
        <label class="form__label" for="BundleColor{{ i }}-{{ section_id }}">Select Color #{{ i }}</label>

        <div class="select">
          <select
            class="select__select"
            id="BundleColor{{ i }}-{{ section_id }}"
            name="properties[Select Color #{{ i }}]"
            autocomplete="off"
          >
            <option value="" selected>Please select</option>
            {% for c in fireball_colors %}
              <option value="{{ c }}">{{ c }}</option>
            {% endfor %}
          </select>
          <span class="icon-caret">
            {{- 'icon-caret.svg' | inline_asset_content -}}
          </span>
        </div>
      </div>
    {% endfor %}
  </fieldset>
</div>

<style>
  /* Fireball - keep it native Dawn */
  #FireballBundleColors-{{ section_id }}.hidden { display: none; }

  /* spacing to match Dawn fields */
  #FireballBundleColors-{{ section_id }} .fireball-bundle-row { 
    margin: 0.5rem 0 1rem; 
  }
  #FireballBundleColors-{{ section_id }} .form__label { 
    margin-bottom: .25rem; 
  }

  /* prevent select from getting squashed in grid/containers */
  #FireballBundleColors-{{ section_id }} .select { 
    width: 100%; 
  }
  #FireballBundleColors-{{ section_id }} .select__select { 
    width: 100%; 
    min-width: 0; 
  }
</style>

<script>
/* Fireball â€“ PDP + Featured Product (Dawn 15.4.x)
   Deterministic detection:
   - Identify the "pack/count" option by label (e.g., Pack, Pack Size, Count, Bundle, Set, Qty, Quantity).
   - Read ONLY the currently selected value of that option.
   - Parse it for 2 or 4 (supports "2 Pack", "Set of 2", "Two", "x2", etc.)
   - Show 0/2/4 rows accordingly.
   - Hard-block Add to cart + dynamic checkout until all visible selects are chosen.
   - Built-in HUD + console logs for quick debugging.
*/
(function () {
  const sectionId = "{{ section_id }}";
  const wrapper = document.getElementById(`FireballBundleColors-${sectionId}`);
  if (!wrapper) return;

  // Find the real product form for THIS section (homepage + PDP)
  const pf = document.querySelector(`product-form[data-section-id="${sectionId}"]`);
  const form = pf ? pf.querySelector('form[action*="/cart/add"]') : wrapper.closest('form[action*="/cart/add"]');
  if (!form) return;

  // Enable native required validation
  try { form.removeAttribute('novalidate'); } catch (e) {}

  // ----- Configure the labels that indicate the pack/count option -----
  const PACK_OPTION_LABELS = ['pack', 'pack size', 'count', 'bundle', 'set', 'qty', 'quantity'];

  // ----- Matchers -----
  const RX2 = /\b(2\s*[- ]?pack|2\s*pk|set\s*of\s*2|bundle\s*(of\s*)?2|x\s*2|\(2\)|\btwo\b|\b2\b)\b/i;
  const RX4 = /\b(4\s*[- ]?pack|4\s*pk|set\s*of\s*4|bundle\s*(of\s*)?4|x\s*4|\(4\)|\bfour\b|\b4\b)\b/i;

  function parsePack(val) {
    if (!val) return 0;
    if (RX4.test(val)) return 4;
    if (RX2.test(val)) return 2;
    return 0;
  }

  // ----- Find the *pack* control in the DOM (fieldset radio group or select) -----
  function getPackControl() {
    // 1) Fieldsets with a legend
    const fields = form.querySelectorAll('fieldset, .product-form__input, .variant-picker');
    for (const fs of fields) {
      const legend = (fs.querySelector('legend')?.innerText || '').trim().toLowerCase();
      if (legend && PACK_OPTION_LABELS.some(lbl => legend.includes(lbl))) {
        // Prefer a checked radio in this fieldset
        const checked = fs.querySelector('input[type="radio"]:checked');
        if (checked) return { type: 'radio', field: fs, el: checked };
        // Or a select in this field
        const sel = fs.querySelector('select');
        if (sel) return { type: 'select', field: fs, el: sel };
      }
    }

    // 2) Labeled inputs/selects by their <label for> / aria-label
    const controls = form.querySelectorAll('[name^="options"]');
    for (const el of controls) {
      const labelEl = el.id ? form.querySelector(`label[for="${el.id}"]`) : null;
      const labelText = (labelEl?.innerText || el.getAttribute('aria-label') || '').trim().toLowerCase();
      if (labelText && PACK_OPTION_LABELS.some(lbl => labelText.includes(lbl))) {
        if ((el.type === 'radio' || el.type === 'checkbox') && el.checked) {
          return { type: 'radio', field: null, el };
        } else if (el.tagName === 'SELECT') {
          return { type: 'select', field: null, el };
        }
      }
    }

    // 3) Fallback: if there is only ONE option group and its values look like 2/4-pack, use that
    const groups = Array.from(new Set(Array.from(controls).map(el => el.name)));
    if (groups.length === 1) {
      // Try to read its selected value
      const radios = form.querySelectorAll('input[type="radio"][name="' + groups[0] + '"]');
      if (radios.length) {
        const checked = form.querySelector('input[type="radio"][name="' + groups[0] + '"]:checked');
        if (checked) return { type: 'radio', field: null, el: checked };
      }
      const sel = form.querySelector('select[name="' + groups[0] + '"]');
      if (sel) return { type: 'select', field: null, el: sel };
    }

    return null;
  }

  function readSelectedText(ctrl) {
    if (!ctrl) return '';
    if (ctrl.type === 'radio') {
      const input = ctrl.el;
      const lab = input.id ? form.querySelector(`label[for="${input.id}"]`) : null;
      return (input.value || lab?.innerText || '').trim();
    }
    if (ctrl.type === 'select') {
      const sel = ctrl.el;
      const opt = sel.options[sel.selectedIndex];
      return ((opt?.text || opt?.value) || '').trim();
    }
    return '';
  }

  // ----- Compute pack count deterministically -----
  function calcPackCount() {
    const ctrl = getPackControl();
    const selectedText = readSelectedText(ctrl);
    const count = parsePack(selectedText);

    // Debug logs (helpful for homepage differences)
    console.log('[Fireball] pack control:', {
      sectionId, found: !!ctrl, type: ctrl?.type || null, selectedText, count
    });

    return count; // 0, 2, or 4
  }

  // ----- UI + enforcement -----
  function selectionsComplete() {
    if (wrapper.classList.contains('hidden')) return true;
    const rows = wrapper.querySelectorAll('.fireball-bundle-row');
    for (const row of rows) {
      if (row.style.display === 'none') continue;
      const sel = row.querySelector('select');
      if (!sel.value) return false;
    }
    return true;
  }

  function setButtonsEnabled(enabled) {
    const submitBtn = form.querySelector('[type="submit"][name="add"]');
    if (submitBtn) submitBtn.disabled = !enabled;
    const payContainer = form.querySelector('.shopify-payment-button');
    if (payContainer) {
      payContainer.style.pointerEvents = enabled ? '' : 'none';
      payContainer.style.opacity = enabled ? '' : '0.5';
      const innerBtn = payContainer.querySelector('button');
      if (innerBtn) innerBtn.disabled = !enabled;
    }
  }

  function showRows(count) {
    const rows = wrapper.querySelectorAll('.fireball-bundle-row');
    rows.forEach((row, idx) => {
      const sel = row.querySelector('select');
      if (idx + 1 <= count) {
        row.style.display = '';
        sel.setAttribute('required', 'required');
      } else {
        row.style.display = 'none';
        sel.removeAttribute('required');
        sel.value = '';
      }
    });
    wrapper.classList.toggle('hidden', count === 0);
    setButtonsEnabled(selectionsComplete());

    // Mini HUD for quick visual debug
    let hud = wrapper.querySelector('[data-fireball-hud]');
    if (!hud) {
      hud = document.createElement('div');
      hud.setAttribute('data-fireball-hud','');
      hud.style.cssText='margin-top:6px;font:12px/1.35 system-ui,Arial;padding:6px 8px;border:1px solid #ddd;border-radius:6px;background:#f7f7f7;color:#333';
      wrapper.appendChild(hud);
    }
    hud.textContent = `ðŸ§ª Pack: ${count} â€¢ Complete: ${selectionsComplete()}`;
  }

  function refresh() {
    showRows(calcPackCount());
  }

  // Block standard submits
  form.addEventListener('submit', function (ev) {
    if (!selectionsComplete()) {
      ev.preventDefault();
      ev.stopImmediatePropagation();
      alert('Please choose a color for each jar in your bundle.');
      return false;
    }
  });

  // HARD BLOCK Add to cart + dynamic checkout (capture phase)
  (function enforceButtons() {
    function guard(e) {
      if (!selectionsComplete()) {
        e.preventDefault(); e.stopPropagation(); e.stopImmediatePropagation();
        alert('Please choose a color for each jar in your bundle.');
        return false;
      }
    }
    const atc = form.querySelector('[type="submit"][name="add"]');
    if (atc) atc.addEventListener('click', guard, true);

    function bindPaymentGuards() {
      const payWrap = form.querySelector('.shopify-payment-button');
      if (!payWrap) return;
      payWrap.addEventListener('click', guard, true);
      const unbranded = payWrap.querySelector('.shopify-payment-button__button');
      if (unbranded) unbranded.addEventListener('click', guard, true);
      const more = payWrap.querySelector('.shopify-payment-button__more-options');
      if (more) more.addEventListener('click', guard, true);
    }
    bindPaymentGuards();
    setTimeout(bindPaymentGuards, 400);
    new MutationObserver(bindPaymentGuards).observe(form, { childList: true, subtree: true });
  })();

  // Keep in sync with any option or variant change
  document.addEventListener('variant:change', e => { if (form.contains(e.target)) refresh(); });
  form.addEventListener('change', refresh);
  const idInput = form.querySelector('input[name="id"]');
  if (idInput && 'MutationObserver' in window) {
    new MutationObserver(refresh).observe(idInput, { attributes: true, attributeFilter: ['value'] });
  }

  // Initial paint
  refresh();
  setTimeout(refresh, 0);
})();
</script>
